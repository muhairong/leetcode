# Description

Given an array of integers, return indices of the two numbers such that they add up to a specific target.

You may assume that each input would have exactly one solution, and you may not use the same element twice.

Example:
Given nums = [2, 7, 11, 15], target = 9,

Because nums[0] + nums[1] = 2 + 7 = 9,
return [0, 1].


# Solutions

## 1. O(n²)
```
for (int i = 0; i < v.size(); ++i) {
	for (int j = 0; j < v.size(); ++j) {
		if (v[i] + v[j] == target) {
			ret.push_back(i);
			ret.push_back(j);
		}
	}
}
return ret;
```
### problems:
- dup.
- order.
- wrong answer (duplicate elements).
### modify it:
```
for (int i = 0; i < v.size(); ++i) {
	for (int j = i+1; j < v.size(); ++j) {
		if (v[i] + v[j] == target) {
			ret.push_back(i);
			ret.push_back(j);
		}
	}
}
return ret;
```
### problems:
- order within pair

## 2. O(n)
- find element
- [ ] vector O(n²)
- [ ] map O(logn)
- [x] unordered_map O(n)
```
unordered_map<int, int> dict;
for (int i = 0; i < v.size(); ++i)
	dict[v[i]] = i;
for (int i = 0; i < v.size(); ++i) {
	int t = target - v[i];
	if (dict.count(t) != 0){
		ret.push_back(dict[i]);
		ret.push_back(i);
	}
}
```
example: target=6, an element=3
```
for (int i = 0; i < v.size(); ++i) {
	//int t = target - v[i]; 
	if (dict.count(t) != 0){
		if (v[i] == target - v[i]) //v[i]*2 == target  (overflow)
			return ...
		else
			...
	}
}
```
### optimize it:

